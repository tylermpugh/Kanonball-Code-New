<!DOCTYPE html>
<html>
<head>
    <title>Kanonball</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        window.setup = () => {}; // Placeholder to prevent p5.js errors
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3202768823592239"
        crossorigin="anonymous"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;  /* Stack elements vertically */
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: rgb(200, 200, 255);
        }

        #instructions-button {
            position: absolute;
            top: 0px;
            right: calc(50% - 390px);
            padding: 4px 16px;
            background: none;
            color: black;
            border: none;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 16px;
            z-index: 1000;
            text-decoration: none;
        }

        #instructions-button:hover {
            text-decoration: underline;
        }

        #instructions-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        #instructions-popup.show {
            display: block;
        }
    </style>
</head>
<body>
    <button id="instructions-button">Instructions</button>
    <div id="instructions-popup">
        <div style="background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; font-family: Arial, sans-serif; max-width: 400px; margin: 20px auto;">
            <h2 style="text-align: center; margin-top: 0;">KANONBALL</h2>
            <h3 style="margin-bottom: 10px;">Controls:</h3>
            <ul style="list-style-type: none; padding-left: 0;">
                <li>↑↓←→ - Move player</li>
                <li>SPACE - Fire current weapon</li>
                <li>SHIFT - Cycle weapons</li>
            </ul>
            <h3 style="margin-bottom: 10px;">Objectives:</h3>
            <ul style="list-style-type: none; padding-left: 0;">
                <li>• Survive and score points</li>
                <li>• Grab purple diamonds for power-ups</li>
                <li>• Every 1000 pts grants an extra life</li>
                <li style="color: #FF0000; font-weight: bold;">• DON'T DIE!</li>
            </ul>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules for database functionality
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getDatabase, ref, set, get, onValue } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";

        // Firebase Configuration - connects to your specific Firebase instance
        const firebaseConfig = {
            apiKey: "AIzaSyBGRqbc1ywGkObQpavDriDAmlTMCXUUaDo",
            authDomain: "kanonballgame.firebaseapp.com",
            databaseURL: "https://kanonballgame-default-rtdb.firebaseio.com",
            projectId: "kanonballgame",
            storageBucket: "kanonballgame.firebasestorage.app",
            messagingSenderId: "926622074286",
            appId: "1:926622074286:web:2b2d3cabf2a9c5ed12b43f",
            measurementId: "G-8E78DV529X"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

      // Make p5.js functions available within module scope
        for (const key in window) {
            if (key.startsWith('p5') || key.endsWith('_ARROW') || 
                ['random', 'keyIsDown', 'stroke', 'strokeWeight', 'fill', 'rect', 
                'ellipse', 'dist', 'atan2', 'cos', 'sin', 'millis', 'beginShape', 
                'endShape', 'vertex', 'noStroke', 'textSize', 'text', 'textAlign', 
                'CENTER', 'LEFT', 'floor', 'width', 'height', 'key', 'createCanvas', 
                'background', 'max', 'min', 'keyCode'].includes(key)) {
                if (window[key] !== undefined) {
                    globalThis[key] = window[key];
                }
            }
        }

        // Game Constants
        const WINDOW_WIDTH = 800;
        const WINDOW_HEIGHT = 600;
        const ENEMY_SPAWN_INTERVAL = 1;
        const POWERUP_SCORE_THRESHOLD = 250;
        const POWERUP_DURATION = 5000;
        const MAX_HIGH_SCORES = 5;
        const INITIAL_HIGH_SCORES = [
            { initials: "AAA", score: 1000 },
            { initials: "BBB", score: 800 },
            { initials: "CCC", score: 600 },
            { initials: "DDD", score: 400 },
            { initials: "EEE", score: 200 }
        ];

        // Game State Variables
        let player;
        let enemies = [];
        let score = 0;
        let gameOver = false;
        let powerupManager;
        let highScores = [];
        let isEnteringInitials = false;
        let currentInitials = "AAA";
        let currentInitialIndex = 0;
        let gameInitialized = false;
        let bullets = [];
        let rockets = []; 
        let baseSpawnInterval = .5;  // Starting spawn interval
        let gameStartTime = 0;      // Track when game started
	    let lastEnemySpawn = 0;
        let shapeSize = 10; // Starting size
        let lastLifeGainScore = 0;
        let rocketsUnlocked = false;
        let nukesUnlocked = false;
        let elapsedFrames = 0;
        let floatingTexts = [];  // Array to store floating text objects
        let mineUnlocked = false;
        let shotgunUnlocked = false;
        let railgunUnlocked = false;
        let activeRailgunBeam = null;
        let railgunBeams = [];
        let nuke;

        // Player Class
        class Player {
            static cooldowns = {
                gun: 200,        // Basic gun - rapid fire
                shotgun: 1000,   // Shotgun - moderate cooldown
                rocket: 2000,    // Rocket - longer cooldown
                mine: 3000,      // Mine - significant cooldown
                railgun: 2500,   // Railgun - long cooldown
                nuke: 15000      // Nuke - very long cooldown
            };

            constructor() {
                this.reset();
                this.size = 20;
                this.baseSpeed = 5;
                this.boostSpeed = 8;
                this.currentWeapon = 'gun';
                this.cooldowns = Player.cooldowns;
                this.lastFireTime = {
                    gun: 0,
                    shotgun: 0,
                    rocket: 0,
                    mine: 0,
                    railgun: 0,
                    nuke: 0
                };
            }

    reset() {
        this.x = WINDOW_WIDTH / 2;
        this.y = WINDOW_HEIGHT - 50;
        this.hasShield = false;
        this.hasSpeedBoost = false;
        this.hasMagnet = false;
        this.hasSlowEnemies = false;
        this.hasDoublePoints = false;
        this.hasGun = true;
        this.lives = 3;
        this.currentWeapon = 'gun';

        if (this.lastFireTime) {
            Object.keys(this.lastFireTime).forEach(weapon => {
                this.lastFireTime[weapon] = 0;
            });
        }
    }

    cycleWeapon() {
        const weaponOrder = ['gun'];
        if (score >= 1500) weaponOrder.push('shotgun');
        if (score >= 3000) weaponOrder.push('rocket');
        if (score >= 5000) weaponOrder.push('mine');
        if (score >= 7500) weaponOrder.push('railgun');
        if (score >= 10000) weaponOrder.push('nuke');
        
        let currentIndex = weaponOrder.indexOf(this.currentWeapon);
        currentIndex = (currentIndex + 1) % weaponOrder.length;
        this.currentWeapon = weaponOrder[currentIndex];
    }

    canFire() {
        const currentTime = millis();
        return currentTime - this.lastFireTime[this.currentWeapon] >= this.cooldowns[this.currentWeapon];
    }

    updateLastFireTime() {
        this.lastFireTime[this.currentWeapon] = millis();
    }

    // Rest of the Player class methods...
    move() {
        const currentSpeed = this.hasSpeedBoost ? this.boostSpeed : this.baseSpeed;
        if (keyIsDown(LEFT_ARROW)) this.x -= currentSpeed;
        if (keyIsDown(RIGHT_ARROW)) this.x += currentSpeed;
        if (keyIsDown(UP_ARROW)) this.y -= currentSpeed;
        if (keyIsDown(DOWN_ARROW)) this.y += currentSpeed;
        this.x = (this.x < 0) ? WINDOW_WIDTH : (this.x > WINDOW_WIDTH) ? 0 : this.x;
        this.y = (this.y < 0) ? WINDOW_HEIGHT : (this.y > WINDOW_HEIGHT) ? 0 : this.y;
    }

    draw() {
        stroke(0);
        strokeWeight(2);
        fill(255, 0, 0);
        rect(this.x, this.y, this.size, this.size);
        
        if (this.hasShield) {
            stroke(0, 255, 255);
            strokeWeight(3);
            noFill();
            rect(this.x - 2, this.y - 2, this.size + 4, this.size + 4);
        }
    }
}

        // Enemy Class
        class Enemy {
            constructor() {
                this.size = 15;
                this.baseSpeed = 2;
                this.frozen = false;  // Add this line
                this.respawn();
}

            respawn() {
                const safeRadius = 200;  // Increased from 100 to 200 pixels
                let validPosition = false;
                
                while (!validPosition) {
                    this.x = random(WINDOW_WIDTH);
                    this.y = random(WINDOW_HEIGHT - 100);
                    
                    // Check distance from player
                    const distFromPlayer = dist(this.x, this.y, 
                                            player.x + player.size/2, 
                                            player.y + player.size/2);
                    
                    if (distFromPlayer > safeRadius) {
                        validPosition = true;
                    }
                }
            }

            move(player) {
                if (this.frozen) {
                    return;
                }
                const speed = player.hasSlowEnemies ? this.baseSpeed * 0.5 : this.baseSpeed;
                const angle = atan2(player.y - this.y, player.x - this.x);
                if (player.hasMagnet) {
                    this.x += cos(angle) * speed * 1.5;
                    this.y += sin(angle) * speed * 1.5;
                } else {
                    this.x += cos(angle) * speed;
                    this.y += sin(angle) * speed;
                }
            }

            draw() {
                stroke(0);
                strokeWeight(2);
                 // Change color based on frozen state
                 if (this.frozen) {
                   fill(135, 206, 235);  // Light blue for frozen enemies
                 } else {
                 fill(0, 255, 0);      // Regular green for normal enemies
                }
                 ellipse(this.x, this.y, this.size, this.size);
}

            collidesWithPlayer(player) {
                return dist(this.x, this.y, player.x + player.size / 2, player.y + player.size / 2) < (this.size / 2 + player.size / 2);
            }
        }
        
        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 10;
                this.size = 5;
                
                // Find nearest enemy and calculate direction
                let nearestEnemy = null;
                let shortestDist = Infinity;
                
                enemies.forEach(enemy => {
                    const d = dist(this.x, this.y, enemy.x, enemy.y);
                    if (d < shortestDist) {
                        shortestDist = d;
                        nearestEnemy = enemy;
                    }
                });
        
                if (nearestEnemy) {
                    // Calculate direction vector
                    const angle = atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                    this.dx = cos(angle) * this.speed;
                    this.dy = sin(angle) * this.speed;
                } else {
                    // If no enemies, shoot upward
                    this.dx = 0;
                    this.dy = -this.speed;
                }
            }
    
            update() {
                this.x += this.dx;
                this.y += this.dy;
            }
            
            draw() {
                fill(255, 0, 0);
                noStroke();
                ellipse(this.x, this.y, this.size, this.size);
            }
            
            isOffscreen() {
                return this.x < 0 || this.x > width || this.y < 0 || this.y > height;
            }
            
            hits(enemy) {
                return dist(this.x, this.y, enemy.x, enemy.y) < (this.size/2 + enemy.size/2);
            }
        }

        // Shotgun bullet class - similar to regular bullet but with spread
class ShotgunPellet extends Bullet {
    constructor(x, y, angleOffset) {
        super(x, y);
        // Modify the direction based on spread
        const spreadAngle = atan2(this.dy, this.dx) + angleOffset;
        this.dx = cos(spreadAngle) * this.speed;
        this.dy = sin(spreadAngle) * this.speed;
        this.size = 3;  // Smaller than regular bullets
    }

    draw() {
        fill(255, 165, 0);  // Orange color for shotgun pellets
        noStroke();
        ellipse(this.x, this.y, this.size, this.size);
    }
}

// Railgun laser class
class RailgunBeam {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.duration = 2000;  // 2 seconds in milliseconds
        this.startTime = millis();
        this.width = 8;
        this.length = WINDOW_HEIGHT;
        this.alpha = 255;
    }

    update() {
        const elapsed = millis() - this.startTime;
        const remaining = this.duration - elapsed;
        
        if (remaining < 500) {
            this.alpha = (remaining / 500) * 255;
        }
        
        return remaining > 0;
    }

    draw() {
        // Main beam
        noStroke();
        fill(255, 0, 255, this.alpha);
        rect(this.x - this.width/2, 0, this.width, this.length);
        
        // Glow effect
        for(let i = 1; i <= 3; i++) {
            fill(255, 0, 255, this.alpha * (0.3 / i));
            rect(this.x - (this.width * i)/2, 0, this.width * i, this.length);
        }
    }

    hits(enemy) {
        // Improved hit detection
        return abs(enemy.x - this.x) < (this.width + enemy.size/2);
    }
}

class Rocket {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.speed = 8;
        this.size = 8;
        this.explosionRadius = 50;
        this.dx = 0;
        this.dy = -this.speed;  // Default to moving upward

        // Find nearest enemy and calculate direction
        let nearestEnemy = null;
        let shortestDist = Infinity;

        if (enemies.length > 0) {  // Only search for enemies if there are any
            enemies.forEach(enemy => {
                const d = dist(this.x, this.y, enemy.x, enemy.y);
                if (d < shortestDist) {
                    shortestDist = d;
                    nearestEnemy = enemy;
                }
            });

            if (nearestEnemy) {
                const angle = atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                this.dx = cos(angle) * this.speed;
                this.dy = sin(angle) * this.speed;
            }
        }
    }

    hits(enemy) {
        if (!enemy) return false;
        const d = dist(this.x, this.y, enemy.x, enemy.y);
        // Check if enemy is within blast radius OR direct hit
        return d < this.explosionRadius || d < (this.size / 2 + enemy.size / 2);
    }

    update() {
        this.x += this.dx;
        this.y += this.dy;
    }

    draw() {
        fill(255, 165, 0); // Orange color for rockets
        noStroke();
        ellipse(this.x, this.y, this.size, this.size);
    }

    isOffscreen() {
        return this.x < 0 || this.x > width || this.y < 0 || this.y > height;
    }
}

class Nuke {
    constructor() {
        this.duration = 5000;
        this.activationScore = 2500;
        this.available = true;
        this.numNukesOwned = 1;  // Initialize with 1 nuke
    }

    update() {
        // Empty - no longer needed
    }

    activate() {
        if (this.numNukesOwned > 0) {
            this.numNukesOwned--;
            // Show points for all enemies before removing them
            enemies.forEach(enemy => {
                floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'points'));
                score += player.hasDoublePoints ? 10 : 5;
            });
            enemies.splice(0, enemies.length);
            bullets.splice(0, bullets.length);
            rockets.splice(0, rockets.length);
            
            // Add visual feedback
            floatingTexts.push(new FloatingText(
                WINDOW_WIDTH / 2, 
                WINDOW_HEIGHT / 2, 
                "☢️ NUKE ACTIVATED! ☢️", 
                'powerup'
            ));
        }
    }
}
        // PowerupManager Class
        class PowerupManager {
    constructor() {
        this.reset();
    }

    reset() {
        this.activePowerups = [];
        this.powerupTimers = {
            Speed: 0,
            Shield: 0,
            Magnet: 0,
            SlowEnemies: 0,
            DoublePoints: 0,
            FreezeTime: 0
        };
        this.nextPowerupScore = 100;
        
        // Make sure all powerup effects are cleared
        player.hasSpeedBoost = false;
        player.hasShield = false;
        player.hasMagnet = false;
        player.hasSlowEnemies = false;
        player.hasDoublePoints = false;
        enemies.forEach(e => e.frozen = false);
    }

    update() {
        if (score >= this.nextPowerupScore) {
            this.spawn();
            this.nextPowerupScore += POWERUP_SCORE_THRESHOLD;
        }
        const currentTime = millis();
        for (const [type, endTime] of Object.entries(this.powerupTimers)) {
            if (endTime > 0 && currentTime > endTime) {
                this.deactivatePowerup(type);
            }
        }
    }

    spawn() {
        const newX = random(width);
        const newY = random(height - 100);
        this.activePowerups.push({ x: newX, y: newY, size: 20 });
    }

    randomPowerupType() {
    const types = ["Speed", "Shield", "Magnet", "SlowEnemies", "DoublePoints", 
                  "FreezeTime", "ExtraLife"];
    return types[floor(random(types.length))];
}

collectPowerup(p) {
    const type = this.randomPowerupType();
    
    // Add floating text for powerup collection
    floatingTexts.push(new FloatingText(p.x, p.y, type, false));  // false = not points
    
    switch (type) {
        case "Speed": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasSpeedBoost = true; 
            break;
        case "Shield": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasShield = true; 
            break;
        case "Magnet": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasMagnet = true; 
            break;
        case "SlowEnemies": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasSlowEnemies = true; 
            break;
        case "DoublePoints": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasDoublePoints = true; 
            break;
        case "FreezeTime": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            enemies.forEach(e => e.frozen = true); 
            break;
        case "ExtraLife":  // No timer for ExtraLife
            player.lives++;
            break;
    }
}

deactivatePowerup(type) {
    switch(type) {
        case "Speed": player.hasSpeedBoost = false; break;
        case "Shield": player.hasShield = false; break;
        case "Magnet": player.hasMagnet = false; break;
        case "SlowEnemies": player.hasSlowEnemies = false; break;
        case "DoublePoints": player.hasDoublePoints = false; break;
        case "FreezeTime": enemies.forEach(e => e.frozen = false); break;
    }
    this.powerupTimers[type] = 0;
}

    draw() {
        // Draw powerup diamonds
        for (let i = this.activePowerups.length - 1; i >= 0; i--) {
            const p = this.activePowerups[i];
            fill(255, 215, 0);  // Changed from (128, 0, 128) purple to (255, 215, 0) yellow
            noStroke();
            beginShape();
            vertex(p.x, p.y - p.size / 2);
            vertex(p.x + p.size / 2, p.y);
            vertex(p.x, p.y + p.size / 2);
            vertex(p.x - p.size / 2, p.y);
            endShape(CLOSE);

            if (dist(p.x, p.y, player.x + player.size / 2, player.y + player.size / 2) < 
                (p.size / 2 + player.size / 2)) {
                this.collectPowerup(p);
                this.activePowerups.splice(i, 1);
            }
        }

        // Draw active powerups list at bottom left, stacking upward
        fill(255, 215, 0);
        textSize(24);
        textAlign(LEFT);
        
        // Get active powerups
        const activePowerups = Object.entries(this.powerupTimers)
            .filter(([_, endTime]) => endTime > 0);
        
        // Start from bottom and work up
        activePowerups.forEach(([type, endTime], index) => {
            const remainingTime = floor((endTime - millis()) / 1000) + 1;
            const yPos = height - 30 - (index * 30);  // Start at bottom (30px up) and stack upward
            text(`${type}: ${remainingTime}s`, 20, yPos);
        });
        
        textAlign(LEFT);
    }
}

        // Score handling function
        function incrementScore() {
    const pointValue = player.hasDoublePoints ? 2 : 1;
    score += pointValue;
}

        // Firebase Functions
        async function initializeHighScores() {
            const highScoresRef = ref(database, 'highScores');
            try {
                const snapshot = await get(highScoresRef);
                if (snapshot.exists()) {
                    highScores = snapshot.val();
                } else {
                    highScores = INITIAL_HIGH_SCORES;
                    await saveHighScores();
                }
            } catch (error) {
                console.error("Error initializing high scores:", error);
                highScores = INITIAL_HIGH_SCORES;
            }
        }

        function saveHighScores() {
            const highScoresRef = ref(database, 'highScores');
            set(highScoresRef, highScores);
        }

        function setupFirebaseListeners() {
            const highScoresRef = ref(database, 'highScores');
            onValue(highScoresRef, (snapshot) => {
                if (snapshot.exists()) {
                    highScores = snapshot.val();
                }
            });
        }

        // Game Functions
        function resetGame() {
            try {
                console.log("Starting game reset");
                // Clear all arrays
                enemies = [];
                bullets = [];
                rockets = [];
                railgunBeams = [];
                activeRailgunBeam = null;
                railgunUnlocked = false;
                floatingTexts = [];
                
                // Reset game objects
                player = new Player();
                powerupManager = new PowerupManager();
                nuke = new Nuke();  // Ensure nuke is initialized
                
                // Reset all game state variables
                score = 0;
                gameOver = false;
                lastEnemySpawn = floor(millis() / 1000);
                gameStartTime = floor(millis() / 1000);
                baseSpawnInterval = 0.5;
                lastLifeGainScore = 0;
                elapsedFrames = 0;
                
                // Reset weapon unlock states
                rocketsUnlocked = false;
                nukesUnlocked = false;
                mineUnlocked = false;
                shotgunUnlocked = false;
                railgunUnlocked = false;
                
                // Spawn initial entities
                enemies.push(new Enemy());
                
                gameInitialized = true;
                console.log("Game reset completed successfully");

            } catch (error) {
                console.error("Error in resetGame:", error);
                gameInitialized = false;
            }
        }
        function drawEnemies() {
            enemies.forEach(enemy => enemy.draw());
        }
        function updateEnemies() {
            const currentTime = floor(millis() / 1000);
            
            // Calculate spawn count based on elapsed frames
            const baseSpawnCount = 1;
            const additionalSpawns = elapsedFrames * 0.001;  // Increased from 0.0009 to 0.001
            let spawnCount = Math.floor(baseSpawnCount + additionalSpawns);
            
            // Handle fractional spawns by randomly adding an extra enemy
            const fractionalPart = (baseSpawnCount + additionalSpawns) - spawnCount;
            if (random() < fractionalPart) {
                spawnCount += 1;
            }

            // Spawn enemies at regular interval
            if (currentTime - lastEnemySpawn >= ENEMY_SPAWN_INTERVAL) {
                for(let i = 0; i < spawnCount; i++) {
                    enemies.push(new Enemy());
                }
                lastEnemySpawn = currentTime;
            }

            enemies.forEach(enemy => enemy.move(player));
        }

        function checkCollisions() {
            for (const enemy of enemies) {
                if (enemy.collidesWithPlayer(player)) {
                    if (player.hasShield) {
                        floatingTexts.push(new FloatingText(enemy.x, enemy.y));
                        score += player.hasDoublePoints ? 10 : 5;
                        const index = enemies.indexOf(enemy);
                        if (index > -1) {
                            enemies.splice(index, 1);
                        }
                        continue;
                    }

                    player.lives--;
                    floatingTexts.push(new FloatingText(enemy.x, enemy.y));
                    score += player.hasDoublePoints ? 10 : 5;
                    const index = enemies.indexOf(enemy);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }

                    if (player.lives <= 0) {
                        gameOver = true;
                        if (score > highScores[MAX_HIGH_SCORES - 1].score) {
                            isEnteringInitials = true;
                        }
                    }
                }
            }
        }


        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update();
                
                // Check for collisions with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (bullets[i] && bullets[i].hits(enemies[j])) {
                        floatingTexts.push(new FloatingText(enemies[j].x, enemies[j].y));
                        score += player.hasDoublePoints ? 10 : 5;
                        enemies.splice(j, 1);
                        bullets.splice(i, 1);
                        break;
                    }
                }
        
        // Remove offscreen bullets
        if (bullets[i] && bullets[i].isOffscreen()) {
            bullets.splice(i, 1);
        }
    }
}

function updateRockets() {
    console.log("Updating rockets, count:", rockets.length);
    rockets = rockets.filter(rocket => rocket !== null && rocket !== undefined);
    
    for (let i = rockets.length - 1; i >= 0; i--) {
        if (!rockets[i]) {
            console.log("Skipping null rocket at index", i);
            continue;
        }
        
        rockets[i].update();
        
        if (rockets[i].isOffscreen()) {
            console.log("Removing offscreen rocket at index", i);
            rockets.splice(i, 1);
            continue;
        }

        // Store enemies to remove and their positions for drops
        let enemiesHit = [];
        
        // Check all enemies in blast radius
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (!enemies[j] || !rockets[i]) continue;
            
            if (rockets[i].hits(enemies[j])) {
                // Store enemy info for later removal and drops
                enemiesHit.push({
                    index: j,
                    x: enemies[j].x,
                    y: enemies[j].y
                });
            }
        }
        
        // If we hit any enemies, remove the rocket and process all hits
        if (enemiesHit.length > 0) {
            // Remove rocket
            rockets.splice(i, 1);
            
            // Process all enemy hits (from highest index to lowest)
            enemiesHit.sort((a, b) => b.index - a.index).forEach(hit => {
                floatingTexts.push(new FloatingText(hit.x, hit.y));
                score += player.hasDoublePoints ? 10 : 5;
                enemies.splice(hit.index, 1);
            });
        }
    }
}

function updateRailgunBeams() {
    console.log("Updating railgun beams:", railgunBeams.length);
    for (let i = railgunBeams.length - 1; i >= 0; i--) {
        const beam = railgunBeams[i];
        if (!beam.update()) {
            railgunBeams.splice(i, 1);
            if (beam === activeRailgunBeam) {
                activeRailgunBeam = null;
            }
            continue;
        }
        
        // Check for enemy hits
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (beam.hits(enemies[j])) {
                floatingTexts.push(new FloatingText(enemies[j].x, enemies[j].y, 'points'));
                score += player.hasDoublePoints ? 10 : 5;
                enemies.splice(j, 1);
            }
        }
    }
}

function drawRailgunBeams() {
    railgunBeams.forEach(beam => beam.draw());
}

function updateGame() {
    nuke.update();
}

function checkLifeGain() {
    // Weapon unlocks based on score
    if (score >= 1500 && !shotgunUnlocked) {
        shotgunUnlocked = true;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "SHOTGUN UNLOCKED!", "powerup"));
    }
    
    if (score >= 3000 && !rocketsUnlocked) {
        rocketsUnlocked = true;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "ROCKETS UNLOCKED!", "powerup"));
    }

    if (score >= 5000 && !mineUnlocked) {
        mineUnlocked = true;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "MINES UNLOCKED!", "powerup"));
    }

    if (score >= 7500 && !railgunUnlocked) {
        railgunUnlocked = true;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "RAILGUN UNLOCKED!", "powerup"));
    }

    if (score >= 10000 && !nukesUnlocked) {
        nukesUnlocked = true;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "NUKE UNLOCKED!", "powerup"));
    }
}

// Remove ammo-related display from displayGameInfo
function displayGameInfo() {
    // Display score and lives
    fill(255);
    textSize(32);
    text("Score: " + score, 10, 30);
    textSize(24);
    fill(255, 0, 0);
    text("Lives: " + "♥".repeat(player.lives), 10, 60);

    // Display weapons menu
    fill(255);
    textAlign(RIGHT);
    textSize(20);
    let yPos = 30;
    
    // Show available weapons based on score
    text("WEAPONS:", width - 20, yPos);
    yPos += 25;
    
    const weapons = [
        { name: "GUN", unlocked: true },
        { name: "SHOTGUN", unlocked: score >= 1500 },
        { name: "ROCKET", unlocked: score >= 3000 },
        { name: "MINE", unlocked: score >= 5000 },
        { name: "RAILGUN", unlocked: score >= 7500 },
        { name: "NUKE", unlocked: score >= 10000 }
    ];

    weapons.forEach(weapon => {
        if (weapon.unlocked) {
            if (player.currentWeapon === weapon.name.toLowerCase()) {
                fill(255, 0, 0);  // Highlight current weapon
            } else {
                fill(255);
            }
            text(weapon.name, width - 20, yPos);
            yPos += 25;
        }
    });

    textAlign(LEFT);
}

function drawBullets() {
    bullets.forEach(bullet => bullet.draw());
}
        function drawGameOver() {
    background(0);
    fill(255);
    textAlign(CENTER);
    
    if (isEnteringInitials) {
        textSize(48);
        text("NEW HIGH SCORE!", width/2, height/3);
        textSize(32);
        text("Enter Your Initials:", width/2, height/2 - 40);
        
        // Draw initials with current position highlighted
        for (let i = 0; i < 3; i++) {
            if (i === currentInitialIndex) {
                fill(255);  // Keep selected letter white
            } else {
                fill(255, 0, 0);  // Changed from black to red
            }
            text(currentInitials[i], width/2 - 40 + i * 40, height/2 + 20);
        }
        
        textSize(24);
        fill(255);
        text("Use UP/DOWN to change letter", width/2, height/2 + 60);
        text("Use LEFT/RIGHT to move position", width/2, height/2 + 90);
        text("Press ENTER when done", width/2, height/2 + 120);
    } else {
        textSize(64);
        text("GAME OVER", width/2, height/3);
        textSize(32);
        text("Score: " + score, width/2, height/3 + 50);
        
        // Display high scores
        textSize(36);
        text("HIGH SCORES", width/2, height/2);
        textSize(24);
        for (let i = 0; i < MAX_HIGH_SCORES; i++) {
            const hsText = `${i + 1}. ${highScores[i].initials} - ${highScores[i].score}`;
            if (highScores[i].score === score && highScores[i].initials === currentInitials) {
                fill(255, 0, 0);  // Changed from black to red
            } else {
                fill(255);
            }
            text(hsText, width/2, height/2 + 40 + i * 30);
        }
        
        fill(255);
        textSize(24);
        text("Press SPACE to Play Again", width/2, height - 60);
    }
    textAlign(LEFT);
}

function drawRockets() {
    rockets.forEach(rocket => rocket.draw());
}

// 4. Add the missing handleInitialsInput function for high score entry:
function handleInitialsInput() {
    let initialsArray = currentInitials.split('');
    
    if (keyCode === LEFT_ARROW) {
        currentInitialIndex = max(0, currentInitialIndex - 1);
    } else if (keyCode === RIGHT_ARROW) {
        currentInitialIndex = min(2, currentInitialIndex + 1);
    } else if (keyCode === UP_ARROW) {
        initialsArray[currentInitialIndex] = String.fromCharCode(
            ((initialsArray[currentInitialIndex].charCodeAt(0) - 65 + 1) % 26) + 65
        );
    } else if (keyCode === DOWN_ARROW) {
        initialsArray[currentInitialIndex] = String.fromCharCode(
            ((initialsArray[currentInitialIndex].charCodeAt(0) - 65 + 25) % 26) + 65
        );
    } else if (keyCode === ENTER) {
        insertHighScore(currentInitials, score);
        isEnteringInitials = false;
    }
    
    currentInitials = initialsArray.join('');
}

function insertHighScore(initials, score) {
    let inserted = false;
    for (let i = 0; i < MAX_HIGH_SCORES; i++) {
        if (score > highScores[i].score) {
            highScores.splice(i, 0, { initials, score });
            inserted = true;
            break;
        }
    }
    if (inserted) {
        highScores = highScores.slice(0, MAX_HIGH_SCORES);
        saveHighScores();
    }
}

        // p5.js main functions
        window.setup = async function() {
            console.log("Setup starting");
            createCanvas(WINDOW_WIDTH, WINDOW_HEIGHT);
            
            try {
                await initializeHighScores();
                setupFirebaseListeners();
                resetGame();
            } catch (error) {
                console.error("Setup error:", error);
                // Even if Firebase fails, we can still initialize the game
                resetGame();
            }
            
            console.log("Setup completed");
        }

        window.draw = function() {
            try {
                if (!gameInitialized) {
                    console.log("Game not yet initialized, waiting...");
                    background(0);
                    return;
                }
                
                if (gameOver) {
                    drawGameOver();
                    return;
                }

                elapsedFrames++;
                background(0);
                player.move();
                updateEnemies();
                incrementScore();
                checkLifeGain();
                powerupManager.update();
                updateBullets();  
                updateRockets();
                player.draw();
                drawMine();
                drawEnemies();
                drawBullets();
                drawRockets();
                powerupManager.draw();
                updateRailgunBeams();
                drawRailgunBeams();
                drawFloatingTexts();
                displayGameInfo();
                checkCollisions();

            } catch (error) {
                console.error("Error in draw loop:", error);
                gameInitialized = false;
            }
        }

        window.keyPressed = function() {
            if (!player) return;
            
            if (gameOver) {
                if (isEnteringInitials) {
                    handleInitialsInput();
                } else if (key === ' ') {
                    resetGame();
                }
            } else {
                if (key === 'Shift') {
                    player.cycleWeapon();
                    console.log("Weapon cycled to:", player.currentWeapon);
                }
        // Space to fire current weapon if cooldown has expired
        if (key === ' ' && player.canFire()) {
            switch(player.currentWeapon) {
                case 'gun':
                    bullets.push(new Bullet(player.x + player.size/2, player.y + player.size/2));
                    break;

                case 'shotgun':
                    // Create 5 pellets with spread
                    const spreadAngles = [-0.3, -0.15, 0, 0.15, 0.3];
                    spreadAngles.forEach(angle => {
                        bullets.push(new ShotgunPellet(player.x + player.size/2, player.y + player.size/2, angle));
                    });
                    break;

                case 'rocket':
                    rockets.push(new Rocket(player.x + player.size/2, player.y + player.size/2));
                    break;

                case 'mine':
                    if (!player.activeMine) {
                        player.activeMine = new Mine(player.x + player.size/2, player.y + player.size/2);
                    } else {
                        const hitEnemies = player.activeMine.explode();
                        hitEnemies.forEach(enemy => {
                            floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'points'));
                            score += player.hasDoublePoints ? 10 : 5;
                        });
                        floatingTexts.push(new FloatingText(player.activeMine.x, 
                            player.activeMine.y, "BOOM!", "powerup"));
                        enemies = enemies.filter(e => !hitEnemies.includes(e));
                        player.activeMine = null;
                    }
                    break;

                case 'railgun':
                    if (score >= 7500) {  // Check if railgun is unlocked
                        console.log("Firing railgun");
                        const newBeam = new RailgunBeam(player.x + player.size/2, player.y);
                        railgunBeams.push(newBeam);
                        activeRailgunBeam = newBeam;
                    }
                    break;

                case 'nuke':
                    if (nuke && typeof nuke.activate === 'function') {
                        console.log("Activating nuke...");
                        nuke.activate();
                    } else {
                        console.error("Nuke object or activate method not found");
                    }
                    break;
            }
            player.updateLastFireTime();
        }
    }
}

    // Add FloatingText class
    class FloatingText {
        constructor(x, y, text, type = 'points') {  // type can be 'points', 'powerup', or 'ammo'
            this.x = x;
            this.y = y;
            this.alpha = 255;
            this.lifetime = 60;
            // If it's points type, show +5/+10 based on double points
            this.text = type === 'points' ? (player.hasDoublePoints ? "+10" : "+5") : text;
            this.type = type;
        }

        draw() {
            if (this.lifetime > 0) {
                textSize(16);
                switch(this.type) {
                    case 'points':
                        fill(255, 255, 255, this.alpha);  // White
                        break;
                    case 'powerup':
                        fill(255, 215, 0, this.alpha);    // Yellow
                        break;
                    case 'ammo':
                        fill(128, 0, 128, this.alpha);    // Purple
                        break;
                }
                text(this.text, this.x, this.y);
            }
        }

        update() {
            this.y -= 1;  // Float upward
            this.alpha -= 255 / this.lifetime;  // Fade out
            this.lifetime--;
        }
    }

    // Add to draw function
    function drawFloatingTexts() {
        floatingTexts = floatingTexts.filter(text => text.lifetime > 0);
        floatingTexts.forEach(text => {
            text.update();
            text.draw();
        });
    }

    class Mine {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 15;  // Increased size for better visibility
        this.explosionRadius = 80;
        this.pulseSize = 0;  // Add pulse effect
        this.pulseMax = 5;
        this.pulseSpeed = 0.2;
    }

    draw() {
        // Draw the mine with a pulsing effect
        this.pulseSize = (this.pulseSize + this.pulseSpeed) % this.pulseMax;
        
        // Draw outer pulse
        fill(255, 0, 255, 50);  // Semi-transparent purple
        noStroke();
        ellipse(this.x, this.y, this.size + this.pulseSize * 2);
        
        // Draw mine center
        fill(255, 0, 255);  // Solid purple
        stroke(255);  // White border
        strokeWeight(1);
        rect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        
        // Draw crosshair lines
        stroke(255, 100);
        line(this.x - this.size, this.y, this.x + this.size, this.y);
        line(this.x, this.y - this.size, this.x, this.y + this.size);
    }

    explode() {
        return enemies.filter(enemy => {
            const d = dist(this.x, this.y, enemy.x, enemy.y);
            return d < this.explosionRadius;
        });
    }
}

// Add this function to the main game code
function drawMine() {
    if (player.activeMine) {
        player.activeMine.draw();
    }
}
    </script>

<div id="ad-container">
    <ins class="adsbygoogle"
         style="display:block;width:320px;height:50px;margin:auto"
         data-ad-client="ca-pub-3202768823592239"
         data-ad-slot="YOUR_AD_SLOT_ID"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
</body>
</html>