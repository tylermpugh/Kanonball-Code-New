<!DOCTYPE html>
<html>
<head>
    <title>Kanonball</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        window.setup = () => {}; // Placeholder to prevent p5.js errors
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3202768823592239"
        crossorigin="anonymous"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;  /* Stack elements vertically */
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: rgb(200, 200, 255);
        }

        #instructions-button {
            position: absolute;
            top: 0px;
            right: calc(50% - 390px);
            padding: 4px 16px;
            background: none;
            color: black;
            border: none;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 16px;
            z-index: 1000;
            text-decoration: none;
        }

        #instructions-button:hover {
            text-decoration: underline;
        }

        #instructions-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        #instructions-popup.show {
            display: block;
        }
    </style>
</head>
<body>
    <button id="instructions-button">Instructions</button>
    <div id="instructions-popup">
        <div style="background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; font-family: Arial, sans-serif; max-width: 400px; margin: 20px auto;">
            <h2 style="text-align: center; margin-top: 0;">KANONBALL</h2>
            <h3 style="margin-bottom: 10px;">Controls:</h3>
            <ul style="list-style-type: none; padding-left: 0;">
                <li>↑↓←→ - Move player</li>
                <li>SPACE - Fire current weapon</li>
                <li>SHIFT - Cycle weapons</li>
            </ul>
            <h3 style="margin-bottom: 10px;">Objectives:</h3>
            <ul style="list-style-type: none; padding-left: 0;">
                <li>• Survive and score points</li>
                <li>• Grab purple diamonds for power-ups</li>
                <li>• Every 1000 pts grants an extra life</li>
                <li style="color: #FF0000; font-weight: bold;">• DON'T DIE!</li>
            </ul>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules for database functionality
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getDatabase, ref, set, get, onValue } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";

        // Firebase Configuration - connects to your specific Firebase instance
        const firebaseConfig = {
            apiKey: "AIzaSyBGRqbc1ywGkObQpavDriDAmlTMCXUUaDo",
            authDomain: "kanonballgame.firebaseapp.com",
            databaseURL: "https://kanonballgame-default-rtdb.firebaseio.com",
            projectId: "kanonballgame",
            storageBucket: "kanonballgame.firebasestorage.app",
            messagingSenderId: "926622074286",
            appId: "1:926622074286:web:2b2d3cabf2a9c5ed12b43f",
            measurementId: "G-8E78DV529X"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

      // Make p5.js functions available within module scope
for (const key in window) {
    if (key.startsWith('p5') || key.endsWith('_ARROW') || 
        ['random', 'keyIsDown', 'stroke', 'strokeWeight', 'fill', 'rect', 
         'ellipse', 'dist', 'atan2', 'cos', 'sin', 'millis', 'beginShape', 
         'endShape', 'vertex', 'noStroke', 'textSize', 'text', 'textAlign', 
         'CENTER', 'LEFT', 'floor', 'width', 'height', 'key', 'createCanvas', 
         'background', 'max', 'min', 'keyCode'].includes(key)) {
        if (window[key] !== undefined) {
            globalThis[key] = window[key];
        }
    }
}

        // Game Constants
        const WINDOW_WIDTH = 800;
        const WINDOW_HEIGHT = 600;
        const ENEMY_SPAWN_INTERVAL = 1;
        const POWERUP_SCORE_THRESHOLD = 250;
        const POWERUP_DURATION = 5000;
        const MAX_HIGH_SCORES = 5;
        const INITIAL_HIGH_SCORES = [
            { initials: "AAA", score: 1000 },
            { initials: "BBB", score: 800 },
            { initials: "CCC", score: 600 },
            { initials: "DDD", score: 400 },
            { initials: "EEE", score: 200 }
        ];

        // Game State Variables
        let player;
        let enemies = [];
        let score = 0;
        let gameOver = false;
        let powerupManager;
        let highScores = [];
        let isEnteringInitials = false;
        let currentInitials = "AAA";
        let currentInitialIndex = 0;
        let gameInitialized = false;
        let bullets = [];
        let rockets = []; 
        let baseSpawnInterval = .5;  // Starting spawn interval
        let gameStartTime = 0;      // Track when game started
	    let lastEnemySpawn = 0;
        let shapeSize = 10; // Starting size
        let lastLifeGainScore = 0;
        let ammoDrops = [];
        let rocketsUnlocked = false;
        let nukesUnlocked = false;
        let gunDropped = false;
        let gunDrop = null;
        let letterG = null;
        let letterU = null;
        let letterN = null;
        let collectedLetters = {
            G: true,
            U: true,
            N: true
        };
        let elapsedFrames = 0;
        let floatingTexts = [];  // Array to store floating text objects
        let mineUnlocked = false;
        let shotgunUnlocked = false;
        let railgunUnlocked = false;
        let activeRailgunBeam = null;
let railgunBeams = [];

        // Player Class
        class Player {
            constructor() {
                this.reset();
                this.size = 20;
                this.baseSpeed = 5;
                this.boostSpeed = 8;
                this.currentWeapon = 'gun';  // Can be 'none', 'gun', 'rocket', 'nuke'
            }

            reset() {
                this.x = WINDOW_WIDTH / 2;
                this.y = WINDOW_HEIGHT - 50;
                this.hasShield = false;
                this.hasSpeedBoost = false;
                this.hasMagnet = false;
                this.hasSlowEnemies = false;
                this.hasDoublePoints = false;
                this.hasGun = true;  // Always true from start
                this.bullets = 25;   // Start with bullets
                this.shotgunAmmo = 0;
                this.rockets = 0;
                this.tripmines = 0;
                this.railgunAmmo = 0;
                this.lives = 3;
                this.currentWeapon = 'gun';  // Start with regular gun
            }

            move() {
                const currentSpeed = this.hasSpeedBoost ? this.boostSpeed : this.baseSpeed;
                if (keyIsDown(LEFT_ARROW)) this.x -= currentSpeed;
                if (keyIsDown(RIGHT_ARROW)) this.x += currentSpeed;
                if (keyIsDown(UP_ARROW)) this.y -= currentSpeed;
                if (keyIsDown(DOWN_ARROW)) this.y += currentSpeed;
                this.x = (this.x < 0) ? WINDOW_WIDTH : (this.x > WINDOW_WIDTH) ? 0 : this.x;
                this.y = (this.y < 0) ? WINDOW_HEIGHT : (this.y > WINDOW_HEIGHT) ? 0 : this.y;
            }

            draw() {
                // Draw player
                stroke(0);
                strokeWeight(2);
                fill(255, 0, 0);
                rect(this.x, this.y, this.size, this.size);
                
                // Draw shield if active
                if (this.hasShield) {
                    // Draw shield outline (back to original size)
                    stroke(0, 255, 255);  // Cyan
                    strokeWeight(3);
                    noFill();
                    rect(this.x - 2, this.y - 2, this.size + 4, this.size + 4);
                    
                    // Draw cooldown circle
                    const remaining = (powerupManager.powerupTimers.Shield - millis()) / POWERUP_DURATION;
                    const angle = remaining * TWO_PI;  // Convert to radians (full circle = TWO_PI)
                    
                    // Draw cooldown circle in top-right corner
                    noStroke();
                    fill(0, 255, 255, 100);  // Transparent cyan
                    arc(this.x + this.size + 8, this.y - 8,  // Position
                        12, 12,                               // Size
                        -HALF_PI,                            // Start at top
                        -HALF_PI + angle,                    // End based on remaining time
                        PIE);                                // PIE mode for filled arc
                }

                // Draw current weapon name above player if it's not 'none'
                if (this.currentWeapon !== 'none') {
                    textSize(12);
                    fill(255, 0, 0);  // Red text
                    textAlign(CENTER);
                    const displayText = this.currentWeapon === 'gun' ? 'BULLETS' : this.currentWeapon.toUpperCase();
                    text(displayText, this.x + this.size/2, this.y - 5);
                    textAlign(LEFT);
                }
            }

            cycleWeapon() {
        const weaponOrder = ['gun'];
        if (shotgunUnlocked) weaponOrder.push('shotgun');
        if (rocketsUnlocked) weaponOrder.push('rocket');
        if (mineUnlocked) weaponOrder.push('mine');
        if (railgunUnlocked) weaponOrder.push('railgun');
        if (nukesUnlocked) weaponOrder.push('nuke');

        // Find current weapon index
        let currentIndex = weaponOrder.indexOf(this.currentWeapon);
        
        // Try each next weapon in sequence until we find one with ammo
        let foundValidWeapon = false;
        let checkedCount = 0;
        
        while (!foundValidWeapon && checkedCount < weaponOrder.length) {
            currentIndex = (currentIndex + 1) % weaponOrder.length;
            const nextWeapon = weaponOrder[currentIndex];
            
            // Check if we have ammo for this weapon
            switch(nextWeapon) {
                case 'gun':
                    if (this.bullets > 0) foundValidWeapon = true;
                    break;
                case 'shotgun':
                    if (this.shotgunAmmo > 0) foundValidWeapon = true;
                    break;
                case 'rocket':
                    if (this.rockets > 0) foundValidWeapon = true;
                    break;
                case 'mine':
                    if (this.tripmines > 0) foundValidWeapon = true;
                    break;
                case 'railgun':
                    if (this.railgunAmmo > 0) foundValidWeapon = true;
                    break;
                case 'nuke':
                    if (nuke.numNukesOwned > 0) foundValidWeapon = true;
                    break;
            }
            
            if (foundValidWeapon) {
                this.currentWeapon = nextWeapon;
            }
            checkedCount++;
        }
        
        if (!foundValidWeapon) {
            this.currentWeapon = 'gun';  // Default back to gun if no ammo for anything
        }
    }
}


        // Enemy Class
        class Enemy {
    constructor() {
        this.size = 15;
        this.baseSpeed = 2;
        this.frozen = false;  // Add this line
        this.respawn();
}

    respawn() {
        const safeRadius = 200;  // Increased from 100 to 200 pixels
        let validPosition = false;
        
        while (!validPosition) {
            this.x = random(WINDOW_WIDTH);
            this.y = random(WINDOW_HEIGHT - 100);
            
            // Check distance from player
            const distFromPlayer = dist(this.x, this.y, 
                                     player.x + player.size/2, 
                                     player.y + player.size/2);
            
            if (distFromPlayer > safeRadius) {
                validPosition = true;
            }
        }
    }

            move(player) {
                if (this.frozen) {
                    return;
                }
                const speed = player.hasSlowEnemies ? this.baseSpeed * 0.5 : this.baseSpeed;
                const angle = atan2(player.y - this.y, player.x - this.x);
                if (player.hasMagnet) {
                    this.x += cos(angle) * speed * 1.5;
                    this.y += sin(angle) * speed * 1.5;
                } else {
                    this.x += cos(angle) * speed;
                    this.y += sin(angle) * speed;
                }
            }

            draw() {
                stroke(0);
                strokeWeight(2);
                 // Change color based on frozen state
                 if (this.frozen) {
                   fill(135, 206, 235);  // Light blue for frozen enemies
                 } else {
                 fill(0, 255, 0);      // Regular green for normal enemies
                }
                 ellipse(this.x, this.y, this.size, this.size);
}

            collidesWithPlayer(player) {
                return dist(this.x, this.y, player.x + player.size / 2, player.y + player.size / 2) < (this.size / 2 + player.size / 2);
            }
        }
        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 10;
                this.size = 5;
                
                // Find nearest enemy and calculate direction
                let nearestEnemy = null;
                let shortestDist = Infinity;
                
                enemies.forEach(enemy => {
                    const d = dist(this.x, this.y, enemy.x, enemy.y);
                    if (d < shortestDist) {
                        shortestDist = d;
                        nearestEnemy = enemy;
                    }
                });
        
                if (nearestEnemy) {
                    // Calculate direction vector
                    const angle = atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                    this.dx = cos(angle) * this.speed;
                    this.dy = sin(angle) * this.speed;
                } else {
                    // If no enemies, shoot upward
                    this.dx = 0;
                    this.dy = -this.speed;
                }
            }
    
            update() {
                this.x += this.dx;
                this.y += this.dy;
            }
            
            draw() {
                fill(255, 0, 0);
                noStroke();
                ellipse(this.x, this.y, this.size, this.size);
            }
            
            isOffscreen() {
                return this.x < 0 || this.x > width || this.y < 0 || this.y > height;
            }
            
            hits(enemy) {
                return dist(this.x, this.y, enemy.x, enemy.y) < (this.size/2 + enemy.size/2);
            }
        }

        // Shotgun bullet class - similar to regular bullet but with spread
class ShotgunPellet extends Bullet {
    constructor(x, y, angleOffset) {
        super(x, y);
        // Modify the direction based on spread
        const spreadAngle = atan2(this.dy, this.dx) + angleOffset;
        this.dx = cos(spreadAngle) * this.speed;
        this.dy = sin(spreadAngle) * this.speed;
        this.size = 3;  // Smaller than regular bullets
    }

    draw() {
        fill(255, 165, 0);  // Orange color for shotgun pellets
        noStroke();
        ellipse(this.x, this.y, this.size, this.size);
    }
}

// Railgun laser class
class RailgunBeam {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.duration = 2000;  // 2 seconds in milliseconds
        this.startTime = millis();
        this.width = 8;
        this.length = WINDOW_HEIGHT;  // Full screen height
        this.alpha = 255;
    }

    update() {
        // Calculate how much time is left
        const elapsed = millis() - this.startTime;
        const remaining = this.duration - elapsed;
        
        // Update alpha for fade out effect
        if (remaining < 500) {  // Start fading in last 0.5 seconds
            this.alpha = (remaining / 500) * 255;
        }
        
        return remaining > 0;  // Return true if beam should continue
    }

    draw() {
        // Draw the main beam
        noStroke();
        fill(255, 0, 255, this.alpha);  // Purple with alpha
        rect(this.x - this.width/2, 0, this.width, this.length);
        
        // Draw glow effect
        for(let i = 1; i <= 3; i++) {
            fill(255, 0, 255, this.alpha * (0.3 / i));  // Decreasing alpha for glow
            rect(this.x - (this.width * i)/2, 0, this.width * i, this.length);
        }
    }

    hits(enemy) {
        return abs(enemy.x - this.x) < this.width * 1.5;  // Check if enemy touches beam
    }
}

class Rocket {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.speed = 8;
        this.size = 8;
        this.explosionRadius = 50;
        this.dx = 0;
        this.dy = -this.speed;  // Default to moving upward

        // Find nearest enemy and calculate direction
        let nearestEnemy = null;
        let shortestDist = Infinity;

        if (enemies.length > 0) {  // Only search for enemies if there are any
            enemies.forEach(enemy => {
                const d = dist(this.x, this.y, enemy.x, enemy.y);
                if (d < shortestDist) {
                    shortestDist = d;
                    nearestEnemy = enemy;
                }
            });

            if (nearestEnemy) {
                const angle = atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                this.dx = cos(angle) * this.speed;
                this.dy = sin(angle) * this.speed;
            }
        }
    }

    hits(enemy) {
        if (!enemy) return false;
        const d = dist(this.x, this.y, enemy.x, enemy.y);
        // Check if enemy is within blast radius OR direct hit
        return d < this.explosionRadius || d < (this.size / 2 + enemy.size / 2);
    }

    update() {
        this.x += this.dx;
        this.y += this.dy;
    }

    draw() {
        fill(255, 165, 0); // Orange color for rockets
        noStroke();
        ellipse(this.x, this.y, this.size, this.size);
    }

    isOffscreen() {
        return this.x < 0 || this.x > width || this.y < 0 || this.y > height;
    }
}

class Nuke {
    constructor() {
        this.duration = 5000;
        this.activationScore = 2500;
        this.available = true;
        this.numNukesOwned = 0;
    }

    update() {
        // Empty - no longer needed
    }

    activate() {
        if (this.numNukesOwned > 0) {
            this.numNukesOwned--;
            // Try drops and show points for all enemies before removing them
            enemies.forEach(enemy => {
                tryAmmoDrop(enemy.x, enemy.y);
                floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'points'));  // Add white floating text
                score += player.hasDoublePoints ? 10 : 5;  // Add points for each kill
            });
            enemies.splice(0, enemies.length);
            bullets.splice(0, bullets.length);
            rockets.splice(0, rockets.length);
            // ammoDrops.splice(0, ammoDrops.length);  // Commented out - keep ammo drops
            // powerupManager.activePowerups.splice(0, powerupManager.activePowerups.length);  // Commented out - keep powerups
        }
    }
}

const nuke = new Nuke();
     
        // PowerupManager Class
        class PowerupManager {
    constructor() {
        this.reset();
    }

    reset() {
        this.activePowerups = [];
        this.powerupTimers = {
            Speed: 0,
            Shield: 0,
            Magnet: 0,
            SlowEnemies: 0,
            DoublePoints: 0,
            FreezeTime: 0
        };
        this.nextPowerupScore = 100;
        
        // Make sure all powerup effects are cleared
        player.hasSpeedBoost = false;
        player.hasShield = false;
        player.hasMagnet = false;
        player.hasSlowEnemies = false;
        player.hasDoublePoints = false;
        enemies.forEach(e => e.frozen = false);
    }

    update() {
        if (score >= this.nextPowerupScore) {
            this.spawn();
            this.nextPowerupScore += POWERUP_SCORE_THRESHOLD;
        }
        const currentTime = millis();
        for (const [type, endTime] of Object.entries(this.powerupTimers)) {
            if (endTime > 0 && currentTime > endTime) {
                this.deactivatePowerup(type);
            }
        }
    }

    spawn() {
        const newX = random(width);
        const newY = random(height - 100);
        this.activePowerups.push({ x: newX, y: newY, size: 20 });
    }

    randomPowerupType() {
    const types = ["Speed", "Shield", "Magnet", "SlowEnemies", "DoublePoints", 
                  "FreezeTime", "ExtraLife"];
    return types[floor(random(types.length))];
}

collectPowerup(p) {
    const type = this.randomPowerupType();
    
    // Add floating text for powerup collection
    floatingTexts.push(new FloatingText(p.x, p.y, type, false));  // false = not points
    
    switch (type) {
        case "Speed": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasSpeedBoost = true; 
            break;
        case "Shield": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasShield = true; 
            break;
        case "Magnet": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasMagnet = true; 
            break;
        case "SlowEnemies": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasSlowEnemies = true; 
            break;
        case "DoublePoints": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            player.hasDoublePoints = true; 
            break;
        case "FreezeTime": 
            this.powerupTimers[type] = millis() + POWERUP_DURATION;
            enemies.forEach(e => e.frozen = true); 
            break;
        case "ExtraLife":  // No timer for ExtraLife
            player.lives++;
            break;
    }
}

deactivatePowerup(type) {
    switch(type) {
        case "Speed": player.hasSpeedBoost = false; break;
        case "Shield": player.hasShield = false; break;
        case "Magnet": player.hasMagnet = false; break;
        case "SlowEnemies": player.hasSlowEnemies = false; break;
        case "DoublePoints": player.hasDoublePoints = false; break;
        case "FreezeTime": enemies.forEach(e => e.frozen = false); break;
    }
    this.powerupTimers[type] = 0;
}

    draw() {
        // Draw powerup diamonds
        for (let i = this.activePowerups.length - 1; i >= 0; i--) {
            const p = this.activePowerups[i];
            fill(255, 215, 0);  // Changed from (128, 0, 128) purple to (255, 215, 0) yellow
            noStroke();
            beginShape();
            vertex(p.x, p.y - p.size / 2);
            vertex(p.x + p.size / 2, p.y);
            vertex(p.x, p.y + p.size / 2);
            vertex(p.x - p.size / 2, p.y);
            endShape(CLOSE);

            if (dist(p.x, p.y, player.x + player.size / 2, player.y + player.size / 2) < 
                (p.size / 2 + player.size / 2)) {
                this.collectPowerup(p);
                this.activePowerups.splice(i, 1);
            }
        }

        // Draw active powerups list at bottom left, stacking upward
        fill(255, 215, 0);
        textSize(24);
        textAlign(LEFT);
        
        // Get active powerups
        const activePowerups = Object.entries(this.powerupTimers)
            .filter(([_, endTime]) => endTime > 0);
        
        // Start from bottom and work up
        activePowerups.forEach(([type, endTime], index) => {
            const remainingTime = floor((endTime - millis()) / 1000) + 1;
            const yPos = height - 30 - (index * 30);  // Start at bottom (30px up) and stack upward
            text(`${type}: ${remainingTime}s`, 20, yPos);
        });
        
        textAlign(LEFT);
    }
}

        // Score handling function
        function incrementScore() {
    const pointValue = player.hasDoublePoints ? 2 : 1;
    score += pointValue;
}

        // Firebase Functions
        async function initializeHighScores() {
            const highScoresRef = ref(database, 'highScores');
            try {
                const snapshot = await get(highScoresRef);
                if (snapshot.exists()) {
                    highScores = snapshot.val();
                } else {
                    highScores = INITIAL_HIGH_SCORES;
                    await saveHighScores();
                }
            } catch (error) {
                console.error("Error initializing high scores:", error);
                highScores = INITIAL_HIGH_SCORES;
            }
        }

        function saveHighScores() {
            const highScoresRef = ref(database, 'highScores');
            set(highScoresRef, highScores);
        }

        function setupFirebaseListeners() {
            const highScoresRef = ref(database, 'highScores');
            onValue(highScoresRef, (snapshot) => {
                if (snapshot.exists()) {
                    highScores = snapshot.val();
                }
            });
        }

        // Game Functions
        function resetGame() {
    try {
        console.log("Starting game reset");
        // Clear all arrays
        enemies = [];
        bullets = [];
        ammoDrops = [];
        rockets = [];
        
        // Reset game objects
        player = new Player();
        powerupManager = new PowerupManager();
        rocketsUnlocked = false;
        nukesUnlocked = false;
        mineUnlocked = false;
        nuke.numNukesOwned = 0;
        
        // Reset gun collection system
        collectedLetters = {
            G: false,
            U: false,
            N: false
        };
        
        // Reset all game state variables
        score = 0;
        gameOver = false;
        lastEnemySpawn = floor(millis() / 1000);
        gameStartTime = floor(millis() / 1000);
        baseSpawnInterval = .5;
        lastLifeGainScore = 0;
        elapsedFrames = 0;  // Reset frame counter
        
        // Spawn initial entities
        enemies.push(new Enemy());
        
        gameInitialized = true;
        console.log("Game reset completed successfully");
    } catch (error) {
        console.error("Error in resetGame:", error);
        gameInitialized = false;
    }
}
function drawEnemies() {
    enemies.forEach(enemy => enemy.draw());
}
function updateEnemies() {
    const currentTime = floor(millis() / 1000);
    
    // Calculate spawn count based on elapsed frames
    const baseSpawnCount = 1;
    const additionalSpawns = elapsedFrames * 0.001;  // Increased from 0.0009 to 0.001
    let spawnCount = Math.floor(baseSpawnCount + additionalSpawns);
    
    // Handle fractional spawns by randomly adding an extra enemy
    const fractionalPart = (baseSpawnCount + additionalSpawns) - spawnCount;
    if (random() < fractionalPart) {
        spawnCount += 1;
    }

    // Spawn enemies at regular interval
    if (currentTime - lastEnemySpawn >= ENEMY_SPAWN_INTERVAL) {
        for(let i = 0; i < spawnCount; i++) {
            enemies.push(new Enemy());
        }
        lastEnemySpawn = currentTime;
    }

    enemies.forEach(enemy => enemy.move(player));
}
function checkCollisions() {
    for (const enemy of enemies) {
        if (enemy.collidesWithPlayer(player)) {
            if (player.hasShield) {
                console.log("Enemy killed by shield collision - attempting drop");
                tryAmmoDrop(enemy.x, enemy.y);
                floatingTexts.push(new FloatingText(enemy.x, enemy.y));
                score += player.hasDoublePoints ? 10 : 5;
                const index = enemies.indexOf(enemy);
                if (index > -1) {
                    enemies.splice(index, 1);
                }
                continue;
            }

            player.lives--;
            tryAmmoDrop(enemy.x, enemy.y);
            floatingTexts.push(new FloatingText(enemy.x, enemy.y));
            score += player.hasDoublePoints ? 10 : 5;
            const index = enemies.indexOf(enemy);
            if (index > -1) {
                enemies.splice(index, 1);
            }

            if (player.lives <= 0) {
                gameOver = true;
                if (score > highScores[MAX_HIGH_SCORES - 1].score) {
                    isEnteringInitials = true;
                }
            }
        }
    }
}

        function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].update();
        
        // Check for collisions with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (bullets[i] && bullets[i].hits(enemies[j])) {
                console.log("Enemy killed by bullet - attempting drop");
                tryAmmoDrop(enemies[j].x, enemies[j].y);
                floatingTexts.push(new FloatingText(enemies[j].x, enemies[j].y));
                score += player.hasDoublePoints ? 10 : 5;
                enemies.splice(j, 1);
                bullets.splice(i, 1);
                break;
            }
        }
        
        // Remove offscreen bullets
        if (bullets[i] && bullets[i].isOffscreen()) {
            bullets.splice(i, 1);
        }
    }
}

function updateRockets() {
    console.log("Updating rockets, count:", rockets.length);
    rockets = rockets.filter(rocket => rocket !== null && rocket !== undefined);
    
    for (let i = rockets.length - 1; i >= 0; i--) {
        if (!rockets[i]) {
            console.log("Skipping null rocket at index", i);
            continue;
        }
        
        rockets[i].update();
        
        if (rockets[i].isOffscreen()) {
            console.log("Removing offscreen rocket at index", i);
            rockets.splice(i, 1);
            continue;
        }

        // Store enemies to remove and their positions for drops
        let enemiesHit = [];
        
        // Check all enemies in blast radius
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (!enemies[j] || !rockets[i]) continue;
            
            if (rockets[i].hits(enemies[j])) {
                // Store enemy info for later removal and drops
                enemiesHit.push({
                    index: j,
                    x: enemies[j].x,
                    y: enemies[j].y
                });
            }
        }
        
        // If we hit any enemies, remove the rocket and process all hits
        if (enemiesHit.length > 0) {
            // Remove rocket
            rockets.splice(i, 1);
            
            // Process all enemy hits (from highest index to lowest)
            enemiesHit.sort((a, b) => b.index - a.index).forEach(hit => {
                console.log("Enemy killed by rocket - attempting drop");
                tryAmmoDrop(hit.x, hit.y);
                floatingTexts.push(new FloatingText(hit.x, hit.y));
                score += player.hasDoublePoints ? 10 : 5;
                enemies.splice(hit.index, 1);
            });
        }
    }
}
function updateRailgunBeams() {
    for (let i = railgunBeams.length - 1; i >= 0; i--) {
        const beam = railgunBeams[i];
        if (!beam.update()) {
            railgunBeams.splice(i, 1);
            if (beam === activeRailgunBeam) {
                activeRailgunBeam = null;
            }
            continue;
        }
        
        // Check for enemy hits
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (beam.hits(enemies[j])) {
                tryAmmoDrop(enemies[j].x, enemies[j].y);
                floatingTexts.push(new FloatingText(enemies[j].x, enemies[j].y, 'points'));
                score += player.hasDoublePoints ? 10 : 5;
                enemies.splice(j, 1);
            }
        }
    }
}
function drawRailgunBeams() {
    railgunBeams.forEach(beam => beam.draw());
}

function updateGame() {
    nuke.update();
}

function checkLifeGain() {
    // Weapon unlocks based on score
    if (score >= 1500 && !shotgunUnlocked) {
        shotgunUnlocked = true;
        player.shotgunAmmo = 15;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "SHOTGUN UNLOCKED!", "powerup"));
    }
    
    if (score >= 3000 && !rocketsUnlocked) {
        rocketsUnlocked = true;
        player.rockets = 5;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "ROCKETS UNLOCKED!", "powerup"));
    }

    if (score >= 5000 && !mineUnlocked) {
        mineUnlocked = true;
        player.tripmines = 3;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "MINES UNLOCKED!", "powerup"));
    }

    if (score >= 7500 && !railgunUnlocked) {
        railgunUnlocked = true;
        player.railgunAmmo = 10;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "RAILGUN UNLOCKED!", "powerup"));
    }

    if (score >= 10000 && !nukesUnlocked) {
        nukesUnlocked = true;
        nuke.numNukesOwned = 1;
        floatingTexts.push(new FloatingText(player.x, player.y - 20, "NUKE UNLOCKED!", "powerup"));
    }
}

function displayGameInfo() {
    // Display score and lives (keep at top left)
    fill(255);
    textSize(32);
    text("Score: " + score, 10, 30);
    textSize(24);
    fill(255, 0, 0);
    text("Lives: " + "♥".repeat(player.lives), 10, 60);

    // Display GUN text at top right
    fill(255);  // White text
    textAlign(RIGHT);
    textSize(20);
    text("GUN", width - 20, 30);  // Always show GUN at top

    // Display inventory at top right
    if (player.hasGun) {
        let yPos = 60;  // Starting Y position

        // Regular bullets
        text("Bullets: " + player.bullets, width - 20, yPos);
        yPos += 30;
        
        // Shotgun ammo
        if (shotgunUnlocked) {
            text("Shotgun: " + player.shotgunAmmo, width - 20, yPos);
            yPos += 30;
        }

        // Rockets
        if (rocketsUnlocked) {
            text("Rockets: " + player.rockets, width - 20, yPos);
            yPos += 30;
        }

        // Mines
        if (mineUnlocked) {
            text("Mines: " + player.tripmines, width - 20, yPos);
            yPos += 30;
        }

        // Railgun ammo
        if (railgunUnlocked) {
            text("Railgun: " + player.railgunAmmo, width - 20, yPos);
            yPos += 30;
        }

        // Nukes
        if (nukesUnlocked) {
            text("Nukes: " + nuke.numNukesOwned, width - 20, yPos);
        }
    }
    textAlign(LEFT);  // Reset alignment
}

function drawBullets() {
    bullets.forEach(bullet => bullet.draw());
}
        function drawGameOver() {
    background(0);
    fill(255);
    textAlign(CENTER);
    
    if (isEnteringInitials) {
        textSize(48);
        text("NEW HIGH SCORE!", width/2, height/3);
        textSize(32);
        text("Enter Your Initials:", width/2, height/2 - 40);
        
        // Draw initials with current position highlighted
        for (let i = 0; i < 3; i++) {
            if (i === currentInitialIndex) {
                fill(255);  // Keep selected letter white
            } else {
                fill(255, 0, 0);  // Changed from black to red
            }
            text(currentInitials[i], width/2 - 40 + i * 40, height/2 + 20);
        }
        
        textSize(24);
        fill(255);
        text("Use UP/DOWN to change letter", width/2, height/2 + 60);
        text("Use LEFT/RIGHT to move position", width/2, height/2 + 90);
        text("Press ENTER when done", width/2, height/2 + 120);
    } else {
        textSize(64);
        text("GAME OVER", width/2, height/3);
        textSize(32);
        text("Score: " + score, width/2, height/3 + 50);
        
        // Display high scores
        textSize(36);
        text("HIGH SCORES", width/2, height/2);
        textSize(24);
        for (let i = 0; i < MAX_HIGH_SCORES; i++) {
            const hsText = `${i + 1}. ${highScores[i].initials} - ${highScores[i].score}`;
            if (highScores[i].score === score && highScores[i].initials === currentInitials) {
                fill(255, 0, 0);  // Changed from black to red
            } else {
                fill(255);
            }
            text(hsText, width/2, height/2 + 40 + i * 30);
        }
        
        fill(255);
        textSize(24);
        text("Press SPACE to Play Again", width/2, height - 60);
    }
    textAlign(LEFT);
}

function drawRockets() {
    rockets.forEach(rocket => rocket.draw());
}

// 4. Add the missing handleInitialsInput function for high score entry:
function handleInitialsInput() {
    let initialsArray = currentInitials.split('');
    
    if (keyCode === LEFT_ARROW) {
        currentInitialIndex = max(0, currentInitialIndex - 1);
    } else if (keyCode === RIGHT_ARROW) {
        currentInitialIndex = min(2, currentInitialIndex + 1);
    } else if (keyCode === UP_ARROW) {
        initialsArray[currentInitialIndex] = String.fromCharCode(
            ((initialsArray[currentInitialIndex].charCodeAt(0) - 65 + 1) % 26) + 65
        );
    } else if (keyCode === DOWN_ARROW) {
        initialsArray[currentInitialIndex] = String.fromCharCode(
            ((initialsArray[currentInitialIndex].charCodeAt(0) - 65 + 25) % 26) + 65
        );
    } else if (keyCode === ENTER) {
        insertHighScore(currentInitials, score);
        isEnteringInitials = false;
    }
    
    currentInitials = initialsArray.join('');
}

function insertHighScore(initials, score) {
    let inserted = false;
    for (let i = 0; i < MAX_HIGH_SCORES; i++) {
        if (score > highScores[i].score) {
            highScores.splice(i, 0, { initials, score });
            inserted = true;
            break;
        }
    }
    if (inserted) {
        highScores = highScores.slice(0, MAX_HIGH_SCORES);
        saveHighScores();
    }
}

        // p5.js main functions
        window.setup = async function() {
            console.log("Setup starting");
            createCanvas(WINDOW_WIDTH, WINDOW_HEIGHT);
            
            try {
                await initializeHighScores();
                setupFirebaseListeners();
                resetGame();
            } catch (error) {
                console.error("Setup error:", error);
                // Even if Firebase fails, we can still initialize the game
                resetGame();
            }
            
            console.log("Setup completed");
        }

        window.draw = function() {
    try {
        if (!gameInitialized) {
            console.log("Game not yet initialized, waiting...");
            background(0);
            return;
        }
        
        if (gameOver) {
            drawGameOver();
            return;
        }

        elapsedFrames++;  // Increment frame counter
        background(0);
        player.move();
        updateEnemies();
        incrementScore();
        checkLifeGain();
        powerupManager.update();
        updateBullets();  
        updateRockets(); 
        player.draw();
        drawMine();
        drawEnemies();
        drawBullets();    
        drawRockets(); 
        powerupManager.draw();
        updateAmmoDrops();
        drawAmmoDrops();
        updateRailgunBeams();
        drawRailgunBeams();
        drawFloatingTexts();
        displayGameInfo();
        checkCollisions();
    } catch (error) {
        console.error("Error in draw loop:", error);
        gameInitialized = false;
    }
}

window.keyPressed = function() {
    if (!player) return;  // Add this check
    
    if (gameOver) {
        if (isEnteringInitials) {
            handleInitialsInput();
        } else if (key === ' ') {
            resetGame();
        }
    } else {
        // Add debug logs back
        if (key === 'r') {
            console.log("R key pressed");
            console.log("Has rockets:", player.hasRockets);
            console.log("Rocket count:", player.rockets);
        }
        
        if (key === 'Shift' && player.hasGun) {  // Only allow weapon cycling if player has gun
            player.cycleWeapon();
            console.log("Weapon cycled to:", player.currentWeapon);
        }
        
        // Space to fire current weapon
        if (key === ' ' && player.hasGun) {
         switch(player.currentWeapon) {
                case 'gun':
                    if (player.bullets > 0) {
                        bullets.push(new Bullet(player.x + player.size/2, player.y + player.size/2));
                        player.bullets--;
                    }
                    break;
                case 'shotgun':
                    if (player.shotgunAmmo > 0) {
                        // Create 5 pellets with spread
                        const spreadAngles = [-0.3, -0.15, 0, 0.15, 0.3];  // Spread angles in radians
                        spreadAngles.forEach(angle => {
                            bullets.push(new ShotgunPellet(player.x + player.size/2, player.y + player.size/2, angle));
                        });
                        player.shotgunAmmo--;
                    }
                    break;
                case 'rocket':
                    if (player.rockets > 0) {
                        console.log("Firing rocket, remaining rockets:", player.rockets - 1);
                        rockets.push(new Rocket(player.x + player.size/2, player.y + player.size/2));
                        player.rockets--;
                    }
                    break;
                    case 'mine':
                    if (player.tripmines > 0 && !player.activeMine) {
                        console.log("Placing mine");
                        player.activeMine = new Mine(
                            player.x + player.size/2, 
                            player.y + player.size/2
                        );
                        player.tripmines--;
                    } else if (player.activeMine) {
                        console.log("Detonating mine");
                        const hitEnemies = player.activeMine.explode();
                        hitEnemies.forEach(enemy => {
                            tryAmmoDrop(enemy.x, enemy.y);
                            floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'points'));
                            score += player.hasDoublePoints ? 10 : 5;
                        });
                        floatingTexts.push(new FloatingText(player.activeMine.x, 
                            player.activeMine.y, "BOOM!", "powerup"));
                        enemies = enemies.filter(e => !hitEnemies.includes(e));
                        player.activeMine = null;
                    }
                    break;
                case 'railgun':
                    if (player.railgunAmmo > 0 && !activeRailgunBeam) {
                        activeRailgunBeam = new RailgunBeam(player.x + player.size/2, player.y);
                        railgunBeams.push(activeRailgunBeam);
                        player.railgunAmmo--;
                    }
                    break;
                case 'nuke':
                    if (nuke.numNukesOwned > 0) {
                        console.log("Activating nuke");
                        nuke.activate();
                    }
                    break;
            }
        }
    }
}

class AmmoDrop {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;  // 'B', 'R', or 'N'
        this.size = 20;
    }

    draw() {
        textSize(20);
        fill(128, 0, 128);  // Same purple as powerup
        noStroke();
        text(this.type, this.x, this.y);
    }

    collidesWithPlayer(player) {
        return dist(this.x, this.y, player.x + player.size / 2, player.y + player.size / 2) < 
            (this.size / 2 + player.size / 2);
    }
}

// Add ammo drop chance function
function tryAmmoDrop(x, y) {
    const dropChance = 0.1;
    
    if (random() < dropChance) {
        let roll = random();
        let type = 'B';  // Default to bullets
        
        if (score >= 10000) {  // All weapons available
            if (roll < 0.40) type = 'B';        // 40% bullets
            else if (roll < 0.60) type = 'S';    // 20% shotgun
            else if (roll < 0.75) type = 'R';    // 15% rockets
            else if (roll < 0.85) type = 'M';    // 10% mines
            else if (roll < 0.95) type = 'G';    // 10% railgun
            else type = 'N';                     // 5% nukes
        }
        else if (score >= 7500) {  // Up to railgun
            if (roll < 0.45) type = 'B';
            else if (roll < 0.65) type = 'S';
            else if (roll < 0.80) type = 'R';
            else if (roll < 0.90) type = 'M';
            else type = 'G';
        }
        else if (score >= 5000) {  // Up to mines
            if (roll < 0.50) type = 'B';
            else if (roll < 0.70) type = 'S';
            else if (roll < 0.85) type = 'R';
            else type = 'M';
        }
        else if (score >= 3000) {  // Up to rockets
            if (roll < 0.60) type = 'B';
            else if (roll < 0.80) type = 'S';
            else type = 'R';
        }
        else if (score >= 1500) {  // Up to shotgun
            if (roll < 0.70) type = 'B';
            else type = 'S';
        }
        
        ammoDrops.push(new AmmoDrop(x, y, type));
    }
}

// Update updateAmmoDrops to handle mine pickups
function updateAmmoDrops() {
    for (let i = ammoDrops.length - 1; i >= 0; i--) {
        const drop = ammoDrops[i];
        if (drop.collidesWithPlayer(player)) {
            let ammoText;
            switch (drop.type) {
                case 'B':
                    player.bullets += 10;
                    ammoText = "+10 Bullets";
                    break;
                case 'S':
                    player.shotgunAmmo += 5;
                    ammoText = "+5 Shotgun";
                    break;
                case 'R':
                    player.rockets += 3;
                    ammoText = "+3 Rockets";
                    break;
                case 'M':
                    player.tripmines += 2;
                    ammoText = "+2 Mines";
                    break;
                case 'G':
                    player.railgunAmmo += 5;
                    ammoText = "+5 Railgun";
                    break;
                case 'N':
                    nuke.numNukesOwned += 1;
                    ammoText = "+1 Nuke";
                    break;
            }
            floatingTexts.push(new FloatingText(drop.x, drop.y, ammoText, 'ammo'));
            ammoDrops.splice(i, 1);
        }
    }
}

function drawAmmoDrops() {
    ammoDrops.forEach(drop => drop.draw());
}

class GunDrop {
    constructor(x, y, letter) {
        this.x = x;
        this.y = y;
        this.letter = letter;
        this.size = 20;
        this.collected = false;
        this.animating = false;
        this.targetX = 0;
        this.targetY = 30;
        this.animationProgress = 0;
        this.animationDuration = 60;
    }

    collidesWithPlayer(player) {
        return dist(this.x, this.y, player.x + player.size / 2, player.y + player.size / 2) < 
            (this.size / 2 + player.size / 2);
    }

    draw() {
        if (!this.collected) {
            textSize(20);
            fill(128, 0, 128);  // Purple when uncollected
            noStroke();
            text(this.letter, this.x, this.y);
        } else if (this.animating) {
            // Calculate position during animation
            this.animationProgress++;
            const progress = this.animationProgress / this.animationDuration;
            
            // Smooth easing
            const eased = 1 - Math.pow(1 - progress, 3);
            
            // Interpolate position
            const currentX = lerp(this.x, this.targetX, eased);
            const currentY = lerp(this.y, this.targetY, eased);
            
            textSize(20);
            fill(128, 0, 128);
            noStroke();
            text(this.letter, currentX, currentY);
            
            // End animation
            if (this.animationProgress >= this.animationDuration) {
                this.animating = false;
            }
        }
    }
}

    // Add FloatingText class
    class FloatingText {
        constructor(x, y, text, type = 'points') {  // type can be 'points', 'powerup', or 'ammo'
            this.x = x;
            this.y = y;
            this.alpha = 255;
            this.lifetime = 60;
            // If it's points type, show +5/+10 based on double points
            this.text = type === 'points' ? (player.hasDoublePoints ? "+10" : "+5") : text;
            this.type = type;
        }

        draw() {
            if (this.lifetime > 0) {
                textSize(16);
                switch(this.type) {
                    case 'points':
                        fill(255, 255, 255, this.alpha);  // White
                        break;
                    case 'powerup':
                        fill(255, 215, 0, this.alpha);    // Yellow
                        break;
                    case 'ammo':
                        fill(128, 0, 128, this.alpha);    // Purple
                        break;
                }
                text(this.text, this.x, this.y);
            }
        }

        update() {
            this.y -= 1;  // Float upward
            this.alpha -= 255 / this.lifetime;  // Fade out
            this.lifetime--;
        }
    }

    // Add to draw function
    function drawFloatingTexts() {
        floatingTexts = floatingTexts.filter(text => text.lifetime > 0);
        floatingTexts.forEach(text => {
            text.update();
            text.draw();
        });
    }

    class Mine {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 15;  // Increased size for better visibility
        this.explosionRadius = 80;
        this.pulseSize = 0;  // Add pulse effect
        this.pulseMax = 5;
        this.pulseSpeed = 0.2;
    }

    draw() {
        // Draw the mine with a pulsing effect
        this.pulseSize = (this.pulseSize + this.pulseSpeed) % this.pulseMax;
        
        // Draw outer pulse
        fill(255, 0, 255, 50);  // Semi-transparent purple
        noStroke();
        ellipse(this.x, this.y, this.size + this.pulseSize * 2);
        
        // Draw mine center
        fill(255, 0, 255);  // Solid purple
        stroke(255);  // White border
        strokeWeight(1);
        rect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        
        // Draw crosshair lines
        stroke(255, 100);
        line(this.x - this.size, this.y, this.x + this.size, this.y);
        line(this.x, this.y - this.size, this.x, this.y + this.size);
    }

    explode() {
        return enemies.filter(enemy => {
            const d = dist(this.x, this.y, enemy.x, enemy.y);
            return d < this.explosionRadius;
        });
    }
}

// Add this function to the main game code
function drawMine() {
    if (player.activeMine) {
        player.activeMine.draw();
    }
}
    </script>

<div id="ad-container">
    <ins class="adsbygoogle"
         style="display:block;width:320px;height:50px;margin:auto"
         data-ad-client="ca-pub-3202768823592239"
         data-ad-slot="YOUR_AD_SLOT_ID"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
</body>
</html>